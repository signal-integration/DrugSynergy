---
title: "X+Y analysis using random forests"
output: html_document
---

<br />
#### Simulating mean expression for a given integration profile
<br />
Here we generate numerical values (e_0, e_X, e_Y, e_X+Y) representing a given profile. 


```{r message = FALSE, warning = FALSE}
source("compute_profile_means.R")
source("setPowerPointStyle.R")
setPowerPointStyle()

#reading the profile definitions
PROFCODES = read.table("profile_codes_v2.txt",header = TRUE,sep = "\t") 

#this file encodes the system of equalities/inequalities that we want to solve
load("constraints_vector")

prof_index = 2 #index of the profile we want to simulate
ntimes = 1000 #n. of simulations
exp_min = 2 #min range of expression value
exp_max = 16 #max range of expression value
min_delta = 0.5 #minimum non-zero difference among any two comparisons

profile_means = compute_profile_means(PROFCODES, prof_index, ntimes, 
                                      exp_min, exp_max, 
                                      constraints_vector, min_delta)

colnames(profile_means)=c("0","X","Y","X+Y")
head(profile_means)
```


#### Plotting one example
```{r message = FALSE, warning = FALSE}
source("setPowerPointStyle.R")
setPowerPointStyle()

barplot(profile_means[1,-5], ylab = 'simulated expression')
delta_x = profile_means[1,2] - profile_means[1,1]
delta_y = profile_means[1,3] - profile_means[1,1]
add = profile_means[1,1] + delta_x + delta_y
abline(h = add, col="black")
```


#### Simulating random samples for a given inegration profile
After computing the means for a given profile, we can generate random samples resembling real data. We assume that real data come from normal distributions centered around the means computed above. The standard deviation is passed as a parameter, so it is possible to simulate  arbitrary noise levels.

```{r results='hide', message=FALSE, warning=FALSE}
source("simulate_from_means.R")
source("setPowerPointStyle.R")
setPowerPointStyle()

samples = 4 #number of samples for each condition that will be simulated

signal_to_noise = 3

#noise_level = 0.5 #this means that the signal-to-noise is delta/noise_level = 1/0.5

design = factor(c(rep("CTRL", samples), rep("X", samples), rep("Y", samples), rep("Y+X", samples)))

simulated_values = simulate_from_means(profile_means[1,], samples,
                                       signal_to_noise, exp_min, exp_max)
names(simulated_values) = design

boxplot(simulated_values ~ design, ylab = 'simulated expression', col = 'gray')

#stripchart(simulated_values ~ design, vertical = TRUE, 
#    method = "jitter", add = TRUE, pch = 20, col = 'black',cex #= 1.5)

```





Example with more noise.
```{r results = 'hide', message = FALSE, warning = FALSE}
source("setPowerPointStyle.R")
setPowerPointStyle()

signal_to_noise = 1 #this means that the signal-to-noise is delta/noise_level = 1/1

simulated_values = simulate_from_means(profile_means[1,], samples,
                                       signal_to_noise, exp_min, exp_max)

boxplot(simulated_values ~ design, ylab = 'simulated expression', 
        col = 'gray')

stripchart(simulated_values ~ design, vertical = TRUE, 
    method = "jitter", add = TRUE, pch = 20, col = 'black',cex=1.5)

```


#### Extracting statistical features from a noisy input
Let's assume we have a noisy input in the form of N replicates of 0,X, Y, X+Y. We derive a set of statistical features, which will be used as predictors of the true profile in the  classifier. Such features consist of: the Bliss index, the mean expression values in 0,X, Y, X+Y, and the p-values for all possible pairwise tests. We consider both one-tailed, and two-tailed tests of t-test and Wilkoxon. In total, the are 75 variables. These statistical features are computed with the function *match11* as shown below. 

```{r warning = FALSE}
source("extract_stat_features.R")

profile_features = extract_stat_features(simulated_values, design)
length(profile_features)
head(profile_features, 10)
```


### Analyzing a dataset

```{r warning = FALSE}
#data_file = "GSE75003.txt"
data_file = "tnf_ifn_1_v3"
my_data = read.csv(data_file)
#my_data = read.csv(data_file,sep = '\t')
head(my_data)

```

```{r warning=FALSE}
#graphical parameters
source("setPowerPointStyle.R")
setPowerPointStyle()

expression_data = my_data[,-(1:2)]
expression_data = expression_data[-which(apply(expression_data, 1, sd) == 0), ]

if (max(expression_data)>25) expression_data = log2(expression_data)

my.pca <- prcomp(t(expression_data), center = TRUE, scale = TRUE)

#we assume the same number of samples for each condition
samples = ncol(expression_data)/4

cols = c(rep("black", samples), rep("red", samples),
         rep("blue", samples), rep("yellow", samples))

plot(my.pca$x[, 1], my.pca$x[, 2], col = cols,
     xlab = "PC1", ylab = "PC2", pch = 20, cex = 1.5, main = data_file)

legend("bottomleft", pch = 20, col = unique(cols), 
       legend = c("0","X","Y","X+Y"), bty = 'n',cex = 1)
```




### Applying the classification algorithm
```{r warning = FALSE, message = FALSE}
#source("extract_limma_features_v1.R")
#source("find_optimal_match.R")
#source("compute_minimum_delta.R")
source("resolve_integration.R")

#load("classifiers")
#rf_model = classifiers[[3]]

load("rf_model")

PROFCODES = read.table("profile_codes_v2.txt",header = TRUE,sep = "\t") 

#read data file
file_name = "tnf_ifn_1_v3"
combinatorial_data = read.csv("tnf_ifn_1_v3")

samples = ncol(combinatorial_data[,-(1:2)])/4
design = factor(c(rep("CTRL", samples), 
                  rep("X", samples), 
                  rep("Y", samples), 
                  rep("YX", samples)))

results = resolve_integration(combinatorial_data, design, PROFCODES)

#filter results
filtered_results = filter_results(results)


#show frequencies of interactions
outcomes = table(filtered_results[[1]]$type)
barplot(outcomes[c(1,3,2)], names.arg = c("add", "syn", "ant"), col = c("gray70", "blue", "red"))

#visualize_all_profiles(filtered_results[[1]])

#visualize individual genes
em = filtered_results[[1]][filtered_results[[1]]$prof_index == 7,]

#sort by fc
em = em[order(-em$min_fc), ]
k = 5
gene_profile = as.numeric(em[k,3:14])
plot(gene_profile ~ design, main = em[k,2], ylab = 'log2(expr)', xlab = '')
stripchart(gene_profile ~ design, vertical = TRUE, 
    method = "jitter", add = TRUE, pch = 20, col = 'black',
    cex = 1.5)


#save(filtered_results, file = "results_1h")
```


```{r warning = FALSE, message = FALSE}

#load("results_1h")

library(eulerr)

venn_df = filtered_results[[2]][,c(18, 19, 21)]

venn_df[venn_df == -1] = 1
names(venn_df) = c("\U0394IFN", "\U0394TNF", "\U0394IFN+TNF")
plot(euler(venn_df), quantities = T)

```


### alluvial plot
```{r warning = FALSE, message = FALSE}
source("generate_ocean_plot.R")
deg = filtered_results[[1]]

generate_ocean_plot(deg)

```


```{r warning = FALSE, message = FALSE}
library(enrichR)

#remove low-value synergies
deg = deg[deg$prof_index != 7, ]
deg = deg[deg$prof_index != 14, ]
deg$genes = as.character(deg$genes)


#set parameters
all_dbs = listEnrichrDbs()$libraryName
dbs <- all_dbs[94]

n= 20
inter_type = 'N'


joined = data.frame()
gene_set = deg[deg$type == inter_type, 'genes']
enriched <- enrichr(gene_set, dbs)[[1]]
enriched = enriched[order(enriched$P.value)[1:n], 
                    c("Term", "Overlap", "P.value")]
enriched$size = length(gene_set)
enriched$gene_set = 'all'
joined = rbind(joined, enriched)

for (h in c(1, 4, 5)){
  
  gene_set = deg[deg$type == inter_type & deg$case == h, 'genes']
  
  enriched <- enrichr(gene_set, dbs)[[1]]
  enriched = enriched[order(enriched$P.value)[1:n], 
                      c("Term", "Overlap", "P.value")]
  enriched$size = length(gene_set)
  enriched$gene_set = as.character(h)
  joined = rbind(joined, enriched)
  
  }

joined$Term = strtrim(joined$Term, 40)


#manipulate dataframe
joined$score = -log10(joined$P.value)
joined$hits = sapply(strsplit(joined$Overlap, '/'), function(x) as.numeric(x[[1]]))
joined$ratio = joined$hits/joined$size

joined = na.omit(joined)
joined = joined[joined$hits >=2, ]

joined$gene_set = relevel(factor(joined$gene_set), "all")

ggplot(joined, aes(x = gene_set, y = Term))+
  geom_point(aes(size = ratio, fill = score), shape = 21)+ 
  scale_size_area(max_size = 8) + scale_fill_gradient(low = "white", high = "orange") +
  theme_bw()






filtered_idx = c(1, 8, 10, 13, 18, 21, 36, 40, 44, 45, 64, 69, 71, 73, 80)

joined_f = joined[filtered_idx, ]

joined_f$Term = factor(joined_f$Term, levels = rev(joined_f$Term))

joined_f$gene_set = relevel(factor(joined_f$gene_set), "all")


ggplot(joined_f, aes(x = gene_set, y = Term))+
  geom_point(aes(size = ratio, fill = score), shape = 21)+ 
  scale_size_area(max_size = 10) + scale_fill_gradient(low = "white", high = "orange") +
  theme_bw()


```



### enrichment with clusterProfiler
```{r warning = FALSE, message = FALSE}
library(clusterProfiler)
#remove low-value synergies
deg = deg[deg$prof_index != 7, ]
deg = deg[deg$prof_index != 14, ]





add_entrez = bitr(deg[deg$type == 'A', 'genes'], fromType="SYMBOL", toType="ENTREZID", OrgDb="org.Hs.eg.db")

syn_entrez = bitr(deg[deg$type == 'P', 'genes'], fromType="SYMBOL", toType="ENTREZID", OrgDb="org.Hs.eg.db")

ant_entrez = bitr(deg[deg$type == 'N', 'genes'], fromType="SYMBOL", toType="ENTREZID", OrgDb="org.Hs.eg.db")

clusters = list(syn_entrez$ENTREZID, ant_entrez$ENTREZID)

#clusters = list(add_entrez$SYMBOL, syn_entrez$SYMBOL, ant_entrez$SYMBOL)

names(clusters) = c('syn', 'ant')

ck <- compareCluster(geneCluster = clusters, fun = "enrichKEGG", pvalueCutoff = 0.1)
dotplot(ck, showCategory = 1)

ck <- compareCluster(geneCluster = clusters, fun = "enrichGO", OrgDb = "org.Hs.eg.db", ont = 'CC', pvalueCutoff = 0.1)
dotplot(ck, showCategory = 1)







syn_entrez = bitr(deg[deg$type == 'P', 'genes'], fromType="SYMBOL", toType="ENTREZID", OrgDb="org.Hs.eg.db")

syn1_entrez = bitr(deg[deg$type == 'P' & deg$case == 1, 'genes'], fromType="SYMBOL", toType="ENTREZID", OrgDb="org.Hs.eg.db")

syn2_entrez = bitr(deg[deg$type == 'P' & deg$case == 4, 'genes'], fromType="SYMBOL", toType="ENTREZID", OrgDb="org.Hs.eg.db")

syn3_entrez = bitr(deg[deg$type == 'P' & deg$case == 5, 'genes'], fromType="SYMBOL", toType="ENTREZID", OrgDb="org.Hs.eg.db")

syn4_entrez = bitr(deg[deg$type == 'P' & deg$case == 8, 'genes'], fromType="SYMBOL", toType="ENTREZID", OrgDb="org.Hs.eg.db")

syn5_entrez = bitr(deg[deg$type == 'P' & deg$case == 9, 'genes'], fromType="SYMBOL", toType="ENTREZID", OrgDb="org.Hs.eg.db")

clusters1 = list(syn_entrez$ENTREZID, 
                syn1_entrez$ENTREZID,
                syn2_entrez$ENTREZID,
                syn3_entrez$ENTREZID,
                syn4_entrez$ENTREZID,
                syn5_entrez$ENTREZID)

#clusters = list(add_entrez$SYMBOL, syn_entrez$SYMBOL, ant_entrez$SYMBOL)

names(clusters1) = c('all_syn', '1', '4a', '4b', '5a', "5b")

ck <- compareCluster(geneCluster = clusters, fun = "enrichKEGG", pvalueCutoff = 0.05)
dotplot(ck, showCategory = 5)


ck <- compareCluster(geneCluster = clusters, fun = "enrichGO", OrgDb = "org.Hs.eg.db", ont = 'BP', pvalueCutoff = 0.01)
dotplot(ck, showCategory = 2)

ck <- compareCluster(geneCluster = clusters, fun = "enrichGO", OrgDb = "org.Hs.eg.db", ont = 'CC', pvalueCutoff = 0.05)
dotplot(ck, showCategory = 5)





ant_entrez = bitr(deg[deg$type == 'N', 'genes'], fromType="SYMBOL", toType="ENTREZID", OrgDb="org.Hs.eg.db")

ant1_entrez = bitr(deg[deg$type == 'N' & deg$case == 1, 'genes'], fromType="SYMBOL", toType="ENTREZID", OrgDb="org.Hs.eg.db")

ant2_entrez = bitr(deg[deg$type == 'N' & deg$case == 4, 'genes'], fromType="SYMBOL", toType="ENTREZID", OrgDb="org.Hs.eg.db")

ant3_entrez = bitr(deg[deg$type == 'N' & deg$case == 5, 'genes'], fromType="SYMBOL", toType="ENTREZID", OrgDb="org.Hs.eg.db")

ant4_entrez = bitr(deg[deg$type == 'N' & deg$case == 6, 'genes'], fromType="SYMBOL", toType="ENTREZID", OrgDb="org.Hs.eg.db")

clusters2 = list(ant_entrez$ENTREZID, 
                ant1_entrez$ENTREZID,
                ant2_entrez$ENTREZID,
                ant3_entrez$ENTREZID,
                ant4_entrez$ENTREZID)

names(clusters2) = c('all_ant', 'a', 'b', 'c', 'd')



ck <- compareCluster(geneCluster = c(clusters1, clusters2), fun = "enrichGO", OrgDb = "org.Hs.eg.db", ont = 'BP', pvalueCutoff = 0.1)
dotplot(ck, showCategory = 1)


ck <- compareCluster(geneCluster = c(clusters1, clusters2), fun = "enrichKEGG", pvalueCutoff = 0.2)
dotplot(ck, showCategory = 2)




dbs <- c("Reactome_2016", "WikiPathways_2016", "KEGG_2016")
enriched <- enrichr(ant4_entrez$SYMBOL, dbs)

```




```{r warning = FALSE, message = FALSE}

type_1h = as.character(my_results_1h$type)
type_1h[my_results_1h$prof_index == 2] = 'const'

type_2.5h = as.character(my_results_2.5h$type)
type_2.5h[my_results_2.5h$prof_index == 2] = 'const'

alluvial_df = melt(table(type_1h, type_2.5h))
alluvial_df = alluvial_df[-which(alluvial_df$type_1h == 'const' & alluvial_df$type_2.5h == 'const'),]
alluvial(alluvial_df[,1:2], freq = alluvial_df$value)


type_1h = as.character(my_results_1h$prof_index)
type_1h[my_results_1h$prof_index == 2] = 'const'

type_2.5h = as.character(my_results_2.5h$prof_index)
type_2.5h[my_results_2.5h$prof_index == 2] = 'const'

alluvial_df = melt(table(type_1h, type_2.5h))
alluvial_df = alluvial_df[-which(alluvial_df$type_1h == 'const' & alluvial_df$type_2.5h == 'const'),]
alluvial_df = alluvial_df[alluvial_df$value > 40, ]
alluvial(alluvial_df[,1:2], freq = alluvial_df$value, hide = 
           alluvial_df$value < 50)




#here transitions
prof_freq_1h = rep(0, 123)
names(prof_freq_1h) = 1:123
prof_freq_1h[names(table(my_results_1h$prof_index))] = table(my_results_1h$prof_index)
prof_freq_1h = prof_freq_1h/sum(prof_freq_1h)

prof_freq_2.5h = rep(0, 123)
names(prof_freq_2.5h) = 1:123
prof_freq_2.5h[names(table(my_results_2.5h$prof_index))] = table(my_results_2.5h$prof_index)
prof_freq_2.5h = prof_freq_2.5h/sum(prof_freq_2.5h)

alluvial_df[,1]

```


```{r warning = FALSE, message = FALSE}


alluvial_cases = melt(table(deg$type, deg$case))
#alluvial_cases = alluvial_cases[alluvial_cases$value > 20, ]

col = as.character(alluvial_cases$Var.1)
col[col == 'A'] = 'gray60'
col[col == 'N'] = 'red'
col[col == 'P'] = 'blue'

alluvial_cases$Var.1 = factor(alluvial_cases$Var.1, levels(alluvial_cases$Var.1)[c(1,3,2)])
levels(alluvial_cases$Var.1)[levels(alluvial_cases$Var.1) =="P"] <- "syn"
levels(alluvial_cases$Var.1)[levels(alluvial_cases$Var.1) == "A"] <- "add"
levels(alluvial_cases$Var.1)[levels(alluvial_cases$Var.1)=="N"] <- "ant"

alluvial(alluvial_cases[,c(1,2)], freq = alluvial_cases$value, col = col, cex = 0.1, alpha=0.7)


alluvial(alluvial_cases[,c(1,2)], freq = alluvial_cases$value, col = col, cex = 0.1, alpha=0.7)


annotation = as.character(alluvial_cases$Var1)
annotation[annotation == 'A'] = 'IFN pathway'
annotation[annotation == 'N'] = 'RNA polymerase'
annotation[annotation == 'P'] = 'TNF'
  
alluvial_cases = add_column(alluvial_cases, Var3 = annotation, .after = 1)


alluvial(alluvial_cases[,1:3], freq = alluvial_cases$value, col = col)
```
